In your third homework assignment you will learn and build a new application on the results of your second homework. Your goal is to gain experience with functional reactive concurrent distributed programming using Actor messaging systems and to understand the Git object model. This is the first homework in CS474 where you will write your code in Scala using the Akka toolkit (http://akka.io) and you will build your project using the SBT. Doing this homework is essential for successful completion of your course project that is based on understanding key modern technologies and language structures to write programs for processing large data streams.

In this homework, you will use the Github Developer API to stream open-source software projects and metainformation about them to determine various statistics and to recommend actions to github developers, for example, to recommend what components of the open-source project should be re-tested based on the diff or the patch created as a result of the last code push. Git patches are metadata files that describe how to apply changes to the source code of the previous version of the application to switch to the next consecutive version of the same application. For example, the following lines in a patch "- int a = 2" and "+ float b = 3" would mean that the declaration and initialization of the variable a in some Java file is replaced with the declaration and initalization of the variable b, hence + and - signs in the beginning of the lines. You can find more information in various sources including the following books that I recommend below (http://rypress.com/tutorials/git/patch-workflows and https://git-scm.com/docs/git-format-patch).

In your Scala program, you will create multiple actors that will handle each other's requests by sending and processing messages, which will be desribed using case classes. For example, one actor will handle the list of public repositories of projects written in Java, some other actors will obtain the content of a file or a directory in a repository, and other actors will automatically analyze the relationships among types in the obtained software application using the Application Programming Interface (API) of the tool called Understand (https://scitools.com/non-commercial-license/), a static code analysis tool that supports many programming languages and it is used by many Fortune 500 companies. Those of you who completed homework 2 (yes, a few students did not!) know how to use this tool already. If you haven't yet, please apply for a non-commercial license immediately, install the tool, and investigate its IDE and its API libraries. You will use the latest community version of IntelliJ IDE for this assignment.

The input to your application is the language which will be used to filter open-source projects. Github is a publically available distributed object and, just like other open-source objects, limits the rate of communications from its non-paying clients to 1,000 projects a day. Some API calls, e.g., GET content, have the upper limits of 1,000 files for a directory and 1MB in size. In many cases, the limits that Github imposes on some API calls can be bypassed by using some other API calls, e.g., GET tree recursively. As some actors obtain the content of various Java open-source projects, the other actors in your program will use the Understand API calls to process the content of the obtained software applications and their patches and construct the dependency graphs. Then, by analyzing the patches, you will determine the nodes in the graph that underwent changes. It means that you will keep track between the source code and the nodes in the dependency graphs. Based on that, you will determine the affected nodes by these changes and recommend the list of these nodes to test. This is the output of your homework.

Your starting point is to read about Akka (http://akka.io/docs/ in addition to multiple books and forums) and work through its examples to understand the abstractions and the functionality of this toolkit, especially Akka HTTP that I want you to use in this homework. Your starting point is to create a design document that shows a message sequence chart or its equivalent, where the actors communicate using sequences of messages. Also, very helpful is a finite state machine where nodes describe states of the programs and edges describe transitions that are facilitated by the messages that actors exchange. Once you have the initial design, you can start prototyping your program by implementing separate elements of its functionality. In a way, you can view this program as a composition of objects that collaborate via messages. It is also a great opportunity for you to start using the Scala collection library to process data that your program obtains from Github. Finally, your documentation should include the description of your abstractions and how they influenced your design and development.

For an additional bonus (up to 5%!) you can integrate other Github data into your project. Your ideas and creativity are highly welcome and will be rewarded! For example, you can obtain issues for each pulled software project and you can attempt to link these issues to specific patches. Or you can link reactions to specific commits and rank program modules w.r.t. reactions types and commits associated with these modules. In short, your additional bonus will be based on how you connect various sources of information, not on simply downloading bits and pieces of information. Let your imagination fly!

This homework differs from the previous two, since you are allowed to form groups. If you want to work alone, it is perfectly fine, however, you can decide to work in a group with up to two more of your classmates. Logistically, one of you will create a private fork and will invite one or two of her classmates with the write access to your fork. You should be careful - once you form a group and write and submit code, you cannot start dividing your work and claim you did most of the work. Your forkmates may turn out to be freeloaders and you will be screwed. Be very careful and make sure that you trust your classmates before forming your group. Neither your TA not I can and will resolve your internal group conflicts. Your submission will include the names of all of your forkmates and you will receive the same grade for this homework. Working in a group will be an excellent opportunity for you to explore branching in git, merging, and resolving semantic conflicts when merging your code changes. Don't pass on this opportunity!

If you submitted your previous homework, it means that you were already added as a member of UIC_CS474_2016 team in Bitbucket. Separate repositories will be created for each of your homeworks and for the course project. You will find a corresponding entry for this homework. You will fork this repository and your fork will be private, no one else besides you, your forkmates, the TA and your course instructor will have access to your fork. Please remember to grant a read access to your repository to your TA and your instructor and write access to your forkmates. You can commit and push your code as many times as you want. Your code will not be visible and it should not be visible to other students except for your forkmate, of course. When you push your project, your instructor and the TA will see you code in your separate private fork. Making your fork public or inviting other students except for your forkmates to join your fork will result in losing your grade. For grading, only the latest push timed before the deadline will be considered. If you push after the deadline, your grade for the homework will be zero. For more information about using git and bitbucket specifically, please use this link as the starting point https://confluence.atlassian.com/bitbucket/bitbucket-cloud-documentation-home-221448814.html. For those of you who still struggle with Git, I keep recommending a book by Ryan Hodson on Ry's Git Tutorial. The other book called Pro Git is written by Scott Chacon and Ben Straub and published by Apress and it is freely available https://git-scm.com/book/en/v2/. There are multiple videos on youtube that go into details of Git organization and use.

As your TA specified, please follow this naming convention while submitting your work : "Firstname_Lastname_hw3", so that we can easily recognize your submission. Those who work in groups can use longer names: "Firstname1_Lastname1_Firstname2_Lastname2_Firstname3_Lastname3_hw3". I repeat, please make sure that you will give both your TA and me read access to your private forked repository.

As usual, I allow you to post questions and replies, statements, comments, discussion, etc. on Piazza either using your names or anonymously. Remember that you cannot share your code and your solutions beyond your forkmate group, but you can ask and advise others using Piazza on where resources and sample programs can be found on the internet, how to resolve dependencies and configuration issues, and how to design the logic of the algorithm, as usual. Yet, your implementation should be your own and you cannot share it beyond your forkmate group. Alternatively, you cannot copy and paste someone else's implementation and put your name on it. Your submissions will be checked for plagiarism. When posting question and answers on Piazza, please select the appropriate folder, i.e., hw3 to ensure that all discussion threads can be easily located.

Submission deadline: Saturday, November 5 at 10PM CST. Your submission will include your source code, the SBT build configuration, the README.md file in the root directory that contains the description of your implementation, how to compile and run it using SBT, and what are the limitations of your implementation.

THE INSTRUCTOR (and the TA) WILL NOT ANSWER ANY REQUESTS FROM STUDENTS STARTING 7PM THE NIGHT BEFORE THE SUBMISSION DEADLINE.

Evaluation criteria:
- the maximum grade for this homework is 7% + up to 5% bonus. Points are subtracted from this maximum grade: for example, saying that 2% is lost if some requirement is not completed means that the resulting grade will be 7%-2% => 4%;
- no comments or highly insufficient comments: up to 2% lost;
- no unit and integration tests: up to 5% lost;
- code does not compile or it crashes without completing the core functionality: up to 5% lost;
- the documentation is missing or insufficient to understand how to compile and run your program: up to 6% lost;
- only a subset of your tests works: up to 3% lost;
- the minimum grade for this homework cannot be less than zero.